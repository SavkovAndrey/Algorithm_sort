#include <iostream>
#include <iomanip>
#include "Func.h"
using namespace std;

//------------------------- СОЗДАНИЕ МАССИВА
int *creat_mass(int size)
{
	int *mass = new int[size];
	return mass;
}

//------------------------- ЗАПОЛНЕНИЕ МАССИВА
void fill_mass(int* mass, int size)
{
	for (int i = 0; i < size; i++)
	{
		mass[i] = rand() % 31 - 15;
	}
	cout << "\nВы перезаписали массив новыми случайными данными!\n\n";
}

//------------------------- ВЫВОД МАССИВА
void output_mass(int* mass, int size)
{
	cout << "\nМассив:\n";
	for (int i = 0; i < size; i++)
	{
		cout << setw(4) << mass[i];
	}
	cout << "\n\n";
}

//------------------------- ВЫВОД МЕНЮ
void menu()
{
	cout << "1 - показать МЕНЮ\n";
	cout << "2 - ПЕРЕЗАПИСАТЬ массив случайными числами\n";
	cout << "3 - ВЫВЕСТИ массив на экран\n";
	cout << "4 - сортировка ПУЗЫРЬКОВАЯ\n";
	cout << "5 - сортировка ПО ВЫБОРУ\n";
	cout << "6 - сортировка ВСТАВКАМИ\n";
	cout << "7 - сортировка ШЕЛЛА\n";
	cout << "8 - сортировка БЫСТРАЯ\n";
	cout << "9 - сортировка СЛИЯНИЕМ\n";
	cout << "0 - выход из программы\n\n";
}

//------------------------- ВЫВОД ПОДМЕНЮ
void Podmenu_4()
{
	cout << "\nКонкретнее: \n";
	cout << "1 - обычная\n2 - оптимизированаая\n3 - рекурсивная\n0 - выход в меню общее\nСделайте выбор: ";
	
}

//------------------------- ВЫВОД ПОДМЕНЮ
void Podmenu_5()
{
	cout << "\nКонкретнее: \n";
	cout << "1 - обычная\n2 - рекурсивная\n0 - выход в меню общее\nСделайте выбор: ";
}

//------------------------- СОРТИРОВКА:  ПУЗЫРЬКОВАЯ
void Bubble(int* mass, int size)
{
	int temp = 0;
	for (int i = 0; i < size - 1; i++)
	{
		for (int j = 0; j < size - i - 1; j++)
		{
			if (mass[j] > mass[j + 1])
			{
				temp = mass[j];
				mass[j] = mass[j + 1];
				mass[j + 1] = temp;
			}
		}
	}
	cout << "\nПроведена Пузырьковая сортировка массива!\n\n";
}

//------------------------- СОРТИРОВКА: ОПТИМИЗИРОВАННАЯ ПУЗЫРЬКОВАЯ
void Opt_bubble(int* mass, int size)
{
	bool finish = false;
	
	do
	{
		finish = false;
		for (int i = 0; i < size - 1; i++)
		{
			if (mass[i] > mass[i + 1])
			{
				swap(mass[i], mass[i + 1]);
				finish = true;
			}
		}
	} while (finish);
	cout << "\nПроведена оптимизированная Пузырьковая сортировка массива!\n\n";
}

//------------------------- СОРТИРОВКА: РЕКУРСИВНАЯ ПУЗЫРЬКОВАЯ
void Recur_bubble(int* mass, int size)
{
	if (size == 1)
	{
		cout << "\nПроведена Рекурсивная Пузырьковая сортировка массива!\n\n";
		return;
	}

	for (int i = 0; i < size - 1; i++)
		if (mass[i] > mass[i + 1])
			swap(mass[i], mass[i + 1]);

	Recur_bubble(mass, size - 1);
}

//------------------------- СОРТИРОВКА: ПО ВЫБОРУ
void Select(int* mass, int size)
{
	int index;
	for (int i = 0; i < size - 1; i++)
	{
		index = i;
		for (int j = i + 1; j < size; j++)
		{
			if (mass[j] < mass[index])
			{
				index = j;
			}
		}
			if (index != i)
			{
				swap(mass[i], mass[index]);
			}
	}
	cout << "\nПроведена сортировка массива ПО ВЫБОРУ!\n\n";
}

//------------------------- СОРТИРОВКА: ПО ВЫБОРУ РЕКУРСИВНАЯ
void Rec_select(int* mass, int size)
{
	if (size == 1)
	{
		cout << "\nПроведена Рекурсивная сортировка массива ПО ВЫБОРУ!\n\n";
		return;
	}
	
	int index = 0;
		for (int i = 0; i < size; i++)
		{
			if (mass[i] < mass[index])
			{
				index = i;
			}
		}
		
		swap(mass[0], mass[index]);          // нулевой элемент будет каждый раз разный, так как мы "смещаем курсор"
		Rec_select(mass + 1, size - 1);      // на каждом шаге уменьшаем размер и "смещаем курсор по массиву"
}

//------------------------- СОРТИРОВКА: ВСТАВКАМИ
void Insert(int* mass, int size)                        //   (по рисунку все понятно)
{ 
	int buff, i, j;                                     // инициируем тут , так как j используется за циклом
	for (i = 1; i < size; i++)
	{
		buff = mass[i];                                 // сохранили текущий элемент
		for (j = i - 1; j >= 0 && mass[j] > buff; j--)  // смотрим все элементы в лево от текущего (и пока они меньше текущего)
		{
			mass[j + 1] = mass[j];                      // переставляем элементы в право 
		}
		mass[j + 1] = buff;                             // в "сам элемент" записываем буфф... в цикле и тут j + 1 РАЗНЫЕ!!
	}                                                   // т.к. последняя итерация даст еще раз j-- 
	cout << "\nПроведена сортировка массива ВСТАВКАМИ!\n\n";
}

//------------------------- СОРТИРОВКА: ВСТАВКАМИ РЕКУРСИЯ
void Rec_insert(int* mass, int size)
{
	if (size <= 1)
	{
		cout << "\nПроведена сортировка массива ВСТАВКАМИ!\n\n";
		return; 
	}

	Rec_insert(mass, size - 1);                          // сначала вызывается size - 1 функций
	
	int buff = mass[size - 1], j;                        // на последнем вызове size = 2 (так как 0 и 1 отрежет if)
		for (j = size - 2; j >= 0 && mass[j] > buff; j--)// таким образом i из итер. метода равен size - 1  
		{                                                // а растет size, так как мы "раскручиваем" вызванные рекурсивно 
			mass[j + 1] = mass[j];                       // функции в обратном порядке
		}
		mass[j + 1] = buff;
	
}

//------------------------- СОРТИРОВКА: ШЕЛЛА
void Shell(int* mass, int size)
{
	for (int step = size / 2; step > 0; step /= 2)
	{
		for (int i = step; i < size; i++)
		{
			int buff = mass[i], j;
			for (j = i; j >= step && mass[j - step] > buff; j -= step)
			{
				mass[j] = mass[j - step];
			}
			mass[j] = buff;
		}
	}
	cout << "\nПроведена сортировка массива ШЕЛЛА!\n\n";
}

//------------------------- СОРТИРОВКА: ШЕЛЛА РЕКУРСИВНАЯ
void Rec_shell(int* mass, int size, int step)                // step вынес в отдельную переменную и уже по ней 
{                                                            // делаю рекурсию ( повторяя цикл из итерац. метода)
		for (int i = step; i < size; i++)
		{
			int buff = mass[i], j;
			for (j = i; j >= step && mass[j - step] > buff; j -= step)
			{
				mass[j] = mass[j - step];
			}
			mass[j] = buff;
		}
	
	if(step > 0)
	Rec_shell(mass, size, step / 2);
}

//------------------------- СОРТИРОВКА: БЫСТРАЯ
void Quick(int* mass, int start, int end)                      // передаем ( массив, с какого элем., по какой элем)
{
	if (start < end)                                           // если есть что сортировать
	{
		int pivot = Partition(mass, start, end);               // получаем индекс pivot элемента после первой 
		                                                       // перестановки элементов в функции Partition
		Quick(mass, start, pivot - 1);                         // сортируем элементы СЛЕВА от pivot
		Quick(mass, pivot + 1, end);                           // сортируем элементы СПРАВА от pivot
	}	
}

//------------------------- СОРТИРОВКА: БЫСТРАЯ (перемещение элементов и возврат ИНДЕКСА pivot)
int Partition(int* mass, int start, int pivot)                 // Функция переставляет все элементы меньшие чем
{                                                              // pivot ЛЕВЕЕ него , а большие ПРАВЕЕ
	int i = start;
	while (i < pivot)                                          // просматриваем с лева-направо но до pivot
	{                                   
		if (mass[i] > mass[pivot] && i == pivot - 1)           // проверяем больше ли ЭЛЕМЕНТ чем PIVOT  
		{                                                      // и !!! НЕ СОСЕДНИЕ ЛИ ОНИ , если СОСЕДНИЕ - просто 
			swap(mass[i], mass[pivot]);                        // меняем местами.
			pivot--;
		}

		else if (mass[i] > mass[pivot])                        // если не СОСЕДНИЕ, но все же ЭЛЕМ. больше PIVOT
		{                                                      // то:
			swap(mass[pivot - 1], mass[pivot]);                // смещаем pivot  в лево 
			swap(mass[i], mass[pivot]);                        // меняем ПРОВЕРЯЕМЫЙ элем. с тем что поменялось с PIVOT
			pivot--;                                           // уменьшаем индекс pivot на 1 ( так как сам элемент 
		}                                                      // сместился в лево на 1), что бы индекс соответствовал
		                                                       // самому ЭЛЕМЕНТУ PIVOT
		else i++;     // увеличиваем только если НЕ было смены элементов ПОТОМУ ЧТО:
	}                 // если была смена, то на месте i-того стоит уже другой элемент и его нужно проверять без сдвига
	
	return pivot;     // возвращаем ИНДЕКС элемента PIVOT и его более не будем трогать в следующих итерациях                                          
}                     // будем сортировать элементы СЛЕВА и СПРАВА от него запуском ДВУХ РЕКУРСИВНЫХ ФУНКЦИЙ Quick

//------------------------- СОРТИРОВКА: СЛИЯНИЕМ
void MergeSort(int* mass, int start, int end)
{
	int mid;
	if (start < end) {

		mid = (start + end) / 2;
		MergeSort(mass, start, mid);                     // при помощи двух рекурсивных вызовов мы разбиваем 
		MergeSort(mass, mid + 1, end);                   // на подмассивы и при "раскручивании" рекурсии
		Merge(mass, start, end, mid);                    // начинают срабатывать Merge, которые при сборке 
	}                                                    // массива, его попутно упорядочивают
}

//------------------------- СОРТИРОВКА: СЛИЯНИЕМ (сборка)
void Merge(int* mass, int start, int end, int mid)       // на каждом шаге сюда попадает дипазон в котором нужно
{                                                        // упорядочить элементы, например (m, 0, 1, 0)
	int *mergedList = new int[end + 1];                  // параметр mid можно было бы вычислить и тут по start и end
	int i, j, k;                                         // mergeList - временный массив для хранения разбитых частей
	i = start;
	k = start;                                    // индекс временного массива (инкременируем, если что-то записали туда)
	j = mid + 1;

	while (i <= mid && j <= end) {               // "от старта до середины" и "от середина + 1 до конца"
		if (mass[i] < mass[j]) {                 // мы сравниваем ПЕРВЫЙ эл. ПЕРВОЙ половины с ПЕРВЫМ эл. ВТОРОЙ половины
			mergedList[k] = mass[i];             // какой оказался больше, тот записываем в ВРЕМЕННЫЙ массив по порядку
			k++;
			i++;                                 // i - индекс первой половины j - индекс второй. 
		}                                        // увеличиваем тот индекс из какой половины взяли элемент
		else {                                   // ну и всегда увеличиваем k, так как это личный индекс врем. мас.
			mergedList[k] = mass[j];
			k++;
			j++;
		}
	}

	while (i <= mid) {                           // Если после верхнего цикла остались эл. в ПЕРВОЙ половине 
		mergedList[k] = mass[i];                 // пишем их во врем. мас.
		k++;
		i++;
	}

	while (j <= end) {                           // Если остались во второй  - то пишем их во врем. мас. 
		mergedList[k] = mass[j];
		k++;
		j++;
	}

	for (i = start; i < k; i++) {                   // когда сформировали упорядоченный ВРЕМЕННЫХ массив, переносим его
		mass[i] = mergedList[i];                    // в основной массив
	}
	delete[] mergedList;                            // временный очищаем...
}